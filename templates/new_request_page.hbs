<section class="dbpo-request digify-form-page">
  <div class="container digify-shell">
    <div class="row justify-content-center">
      <div class="col-12 col-xxl-10">
        <div class="form-header digify-form-hero">
          <h1>{{t 'submit_a_request'}}</h1>
          <p class="form-required-note">Fields marked with an asterisk (*) are required.</p>
        </div>
        <div class="digify-form-card">
          <div id="new-request-form"></div>
        </div>
      </div>
    </div>
  </div>
</section>

<script type="module">
  import { renderNewRequestForm } from "new-request-form";

  const container = document.getElementById("new-request-form");

  const settings = {{json settings}};

  const props = {
    requestForm: {{json new_request_form}},
    newRequestPath: {{json (page_path 'new_request')}},
    parentId: {{json parent.id}},
    parentIdPath: {{json parent.url}},
    locale: {{json help_center.locale}},
    baseLocale: {{json help_center.base_locale}},
    hasAtMentions: {{json help_center.at_mentions_enabled}},
    userRole: {{json user.role}},
    userId: {{json user.id}},
    brandId: {{json brand.id}},
    organizations: {{json user.organizations}},
    wysiwyg: true,
    answerBotModal: {
      answerBot: {{json answer_bot}},
      hasRequestManagement: {{json help_center.request_management_enabled}},
      isSignedIn: {{json signed_in}},
      helpCenterPath: {{json (page_path 'help_center')}},
      requestsPath: {{json (page_path 'requests')}},
      requestPath: {{json (page_path 'request' id=answer_bot.request_id)}}
    },
  };

  renderNewRequestForm(settings, props, container);

  const homePath = {{json (page_path 'help_center')}};
  const storageKey = "digifyRedirectAfterRequest";
  let generatedFieldKey = 0;

  const isGardenComboboxField = (field) => {
    return !!(
      field &&
      typeof field.getAttribute === "function" &&
      field.getAttribute("data-garden-id") === "dropdowns.combobox.field"
    );
  };

  const getFieldContainer = (field) => {
    if (!field) return null;
    if (isGardenComboboxField(field)) return field;
    return (
      field.closest('[data-garden-id="dropdowns.combobox.field"]') ||
      field.closest(".form-field") ||
      field.parentElement ||
      null
    );
  };

  const getFieldFocusTarget = (field) => {
    const container = getFieldContainer(field);
    if (!container) return field;
    if (isGardenComboboxField(container)) {
      return (
        container.querySelector('[data-garden-id="dropdowns.combobox.trigger"]') ||
        container.querySelector('[role="combobox"]') ||
        container.querySelector("button") ||
        field
      );
    }
    return (
      container.querySelector("input:not([type='hidden']), select, textarea, button") ||
      field
    );
  };

  const getFieldLabelNode = (field) => {
    const container = getFieldContainer(field);
    if (!container) return null;
    return (
      container.querySelector('[data-garden-id="dropdowns.combobox.label"]') ||
      container.querySelector("label") ||
      null
    );
  };

  const getFormFields = (form) => {
    return Array.from(form.querySelectorAll("input, select, textarea")).filter((field) => {
      if (!field || field.disabled) return false;
      if ((field.type || "").toLowerCase() === "hidden") return false;
      if (field.closest('[data-garden-id="dropdowns.combobox.field"]')) return false;
      if (field.closest("[hidden]")) return false;
      return true;
    });
  };

  const getFieldKey = (field) => {
    const container = getFieldContainer(field);
    const source =
      isGardenComboboxField(container)
        ? (container.querySelector("input[name], select[name], textarea[name]") || field)
        : field;
    const key = (source && (source.id || source.name)) || (container && container.id) || "";
    if (key) return key;

    if (container) {
      if (!container.dataset.digifyGeneratedKey) {
        generatedFieldKey += 1;
        container.dataset.digifyGeneratedKey = "digify-field-" + generatedFieldKey;
      }
      return container.dataset.digifyGeneratedKey;
    }
    return "";
  };

  const getFeedbackHost = (field) => {
    const focusTarget = getFieldFocusTarget(field);
    const container = getFieldContainer(field);
    return container || focusTarget || field;
  };

  const getFeedbackNode = (field) => {
    const key = getFieldKey(field);
    const host = getFeedbackHost(field);
    if (!key || !host || !host.parentElement) return null;
    return Array.from(host.parentElement.querySelectorAll(".invalid-feedback")).find((node) => {
      return node.getAttribute("data-digify-feedback-for") === key;
    }) || null;
  };

  const ensureFeedbackNode = (field) => {
    const key = getFieldKey(field);
    if (!key) return null;
    const existing = getFeedbackNode(field);
    if (existing) return existing;

    const node = document.createElement("div");
    node.className = "invalid-feedback";
    node.setAttribute("data-digify-feedback-for", key);
    node.hidden = true;
    const host = getFeedbackHost(field);
    if (!host) return null;
    if (isGardenComboboxField(host)) {
      host.appendChild(node);
    } else {
      host.insertAdjacentElement("afterend", node);
    }
    return node;
  };

  const setFieldRequiredIndicator = (field, show) => {
    const label = getFieldLabelNode(field);
    if (!label) return;
    const indicatorClass = "digify-invalid-indicator";
    let indicator = label.querySelector("." + indicatorClass);

    if (show) {
      label.classList.add("digify-invalid-label");
      if (!indicator) {
        indicator = document.createElement("span");
        indicator.className = indicatorClass;
        indicator.setAttribute("aria-hidden", "true");
        indicator.textContent = "Required";
        label.appendChild(indicator);
      }
      return;
    }

    label.classList.remove("digify-invalid-label");
    if (indicator) {
      indicator.remove();
    }
  };

  const setFieldInvalid = (field, message) => {
    const container = getFieldContainer(field);
    const focusTarget = getFieldFocusTarget(field);
    if (field && field.classList) {
      field.classList.add("is-invalid");
    }
    if (focusTarget && focusTarget.classList) {
      focusTarget.classList.add("is-invalid");
      focusTarget.setAttribute("aria-invalid", "true");
    }
    if (container && container.classList) {
      container.classList.add("digify-field-invalid");
    }
    if (field && typeof field.setAttribute === "function") {
      field.setAttribute("aria-invalid", "true");
    }
    setFieldRequiredIndicator(field, true);

    const feedback = ensureFeedbackNode(field);
    if (feedback) {
      feedback.textContent = message || field.validationMessage || "This field is required.";
      feedback.hidden = false;
    }
  };

  const clearFieldInvalid = (field) => {
    const container = getFieldContainer(field);
    const focusTarget = getFieldFocusTarget(field);
    if (field && field.classList) {
      field.classList.remove("is-invalid");
      field.removeAttribute("aria-invalid");
    }
    if (focusTarget && focusTarget.classList) {
      focusTarget.classList.remove("is-invalid");
      focusTarget.removeAttribute("aria-invalid");
    }
    if (container && container.classList) {
      container.classList.remove("digify-field-invalid");
    }
    setFieldRequiredIndicator(field, false);

    const feedback = getFeedbackNode(field);
    if (feedback) {
      feedback.textContent = "";
      feedback.hidden = true;
    }
  };

  const isGardenComboboxRequired = (comboboxField) => {
    if (!comboboxField) return false;
    const explicitRequired = comboboxField.querySelector("[required], [aria-required='true']");
    if (explicitRequired) return true;
    if (comboboxField.classList.contains("required")) return true;
    if (comboboxField.closest(".required")) return true;
    const label = getFieldLabelNode(comboboxField);
    if (label && label.classList.contains("required")) return true;
    const labelText = label ? String(label.textContent || "").trim() : "";
    return labelText.indexOf("*") >= 0;
  };

  const getGardenComboboxValue = (comboboxField) => {
    if (!comboboxField) return "";
    const valueSources = Array.from(
      comboboxField.querySelectorAll("input[name], select[name], textarea[name]")
    );
    for (const source of valueSources) {
      const value = String(source.value || "").trim();
      if (value && value !== "null" && value !== "__none__") {
        return value;
      }
    }
    return "";
  };

  const validateGardenComboboxes = (form, invalidFields) => {
    const comboboxes = Array.from(
      form.querySelectorAll('[data-garden-id="dropdowns.combobox.field"]')
    );

    comboboxes.forEach((combobox) => {
      if (!isGardenComboboxRequired(combobox)) {
        clearFieldInvalid(combobox);
        return;
      }
      if (!getGardenComboboxValue(combobox)) {
        setFieldInvalid(combobox, "This field is required.");
        invalidFields.push(combobox);
        return;
      }
      clearFieldInvalid(combobox);
    });
  };

  const getFieldTopOffset = (field) => {
    const anchor = getFieldFocusTarget(field) || getFieldContainer(field) || field;
    if (!anchor || typeof anchor.getBoundingClientRect !== "function") {
      return Number.POSITIVE_INFINITY;
    }
    const rect = anchor.getBoundingClientRect();
    return rect.top + (window.scrollY || window.pageYOffset || 0);
  };

  const focusAndScrollToField = (field) => {
    if (!field) return;
    const anchor = getFieldFocusTarget(field) || getFieldContainer(field) || field;

    if (anchor && typeof anchor.focus === "function") {
      try {
        anchor.focus({ preventScroll: true });
      } catch (error) {
        anchor.focus();
      }
    }

    if (anchor && typeof anchor.scrollIntoView === "function") {
      anchor.scrollIntoView({
        behavior: "smooth",
        block: "center",
        inline: "nearest"
      });
    }
  };

  const ensureFormErrorSummary = (form) => {
    let summary = form.querySelector("[data-digify-form-error-summary]");
    if (!summary) {
      summary = document.createElement("div");
      summary.className = "alert alert-danger";
      summary.setAttribute("data-digify-form-error-summary", "true");
      summary.setAttribute("role", "alert");
      summary.hidden = true;
      form.prepend(summary);
    }
    return summary;
  };

  const validateForm = (form) => {
    const fields = getFormFields(form);
    const invalidFields = [];

    fields.forEach((field) => {
      if (typeof field.checkValidity !== "function") return;
      if (!field.checkValidity()) {
        setFieldInvalid(field, field.validationMessage);
        invalidFields.push(field);
      } else {
        clearFieldInvalid(field);
      }
    });
    validateGardenComboboxes(form, invalidFields);

    invalidFields.sort((a, b) => getFieldTopOffset(a) - getFieldTopOffset(b));
    const firstInvalid = invalidFields.length ? invalidFields[0] : null;

    const summary = ensureFormErrorSummary(form);
    if (firstInvalid) {
      summary.textContent = "Please complete the highlighted required fields before submitting.";
      summary.hidden = false;
    } else {
      summary.textContent = "";
      summary.hidden = true;
    }

    return firstInvalid;
  };

  const armRedirect = (form) => {
    if (form.dataset.digifyRedirectHooked) return;
    form.dataset.digifyRedirectHooked = "true";

    const onFieldEdit = (event) => {
      const field = event.target;
      if (!field) return;
      const combobox = field.closest('[data-garden-id="dropdowns.combobox.field"]');
      if (combobox) {
        if (!isGardenComboboxRequired(combobox) || getGardenComboboxValue(combobox)) {
          clearFieldInvalid(combobox);
        }
        return;
      }
      if (typeof field.checkValidity !== "function") return;
      if (field.checkValidity()) {
        clearFieldInvalid(field);
      }
    };

    form.addEventListener("input", onFieldEdit, true);
    form.addEventListener("change", onFieldEdit, true);
    form.addEventListener("submit", (event) => {
      const firstInvalid = validateForm(form);
      if (firstInvalid) {
        event.preventDefault();
        event.stopPropagation();
        if (typeof event.stopImmediatePropagation === "function") {
          event.stopImmediatePropagation();
        }
        focusAndScrollToField(firstInvalid);
        if (typeof firstInvalid.reportValidity === "function") {
          firstInvalid.reportValidity();
        }
        return;
      }

      sessionStorage.setItem(
        storageKey,
        JSON.stringify({ target: homePath, timestamp: Date.now() })
      );
    }, true);
  };

  const removeSuggestions = () => {
    const suggestions = container.querySelector('[data-test-id="suggested-articles"]');
    if (suggestions) {
      suggestions.remove();
    }
  };

  const connect = () => {
    const form = container.querySelector("form");
    if (form) {
      armRedirect(form);
      removeSuggestions();
      observer.disconnect();
    }
  };

  const observer = new MutationObserver(connect);
  observer.observe(container, { childList: true, subtree: true });
  connect();
</script>
