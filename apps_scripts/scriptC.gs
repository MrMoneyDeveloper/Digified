/**
 * Script C - Meet Link Generator for Room Bookings
 *
 * Public entrypoint:
 *   createMeetForBooking_C_(params)
 *
 * Backward-compatible wrapper:
 *   createOnlineMeeting(params)
 */

function createMeetForBooking_C_(params) {
  params = params || {};

  var meetingType = normalizeMeetingTypeC_(params.meeting_type);
  var attendeeParse = parseAttendeeEmailsC_(params.attendee_emails);
  var requesterEmail = normalizeEmail_(params.requester_email);
  var requesterName = String(params.requester_name || "").trim() || requesterEmail;
  var timezone = String(params.timezone || params.time_zone || getTzC_()).trim() || getTzC_();
  var calendarId = resolveCalendarIdC_(params.calendar_id);
  var bookingId = String(params.booking_id || "").trim();
  var slotId = String(params.slot_id || "").trim();

  if (meetingType !== "in_person_plus_online") {
    return {
      ok: true,
      status: "skipped",
      meet_link: "",
      event_id: "",
      created_at: "",
      calendar_id: calendarId,
      guests: [],
      message: "Meeting type is in-person only; Meet creation skipped."
    };
  }

  if (!requesterEmail) {
    return failC_("MISSING_REQUESTER_EMAIL", "requester_email is required for hybrid bookings.", "", "", calendarId);
  }

  if (attendeeParse.invalid.length) {
    return failC_(
      "INVALID_ATTENDEE_EMAIL",
      "One or more attendee_emails are invalid.",
      attendeeParse.invalid.join(", "),
      "",
      calendarId
    );
  }

  if (!attendeeParse.valid.length) {
    return failC_(
      "MISSING_REMOTE_ATTENDEES",
      "Hybrid booking requires at least one remote attendee email.",
      "",
      "",
      calendarId
    );
  }

  var slotWindow = resolveSlotWindowC_(params, timezone);
  if (!slotWindow.ok) {
    return failC_(slotWindow.error_code, slotWindow.error_details || "Slot window resolution failed.", "", "", calendarId);
  }

  var guests = buildGuestList_(requesterEmail, attendeeParse.valid);
  var idKey = bookingId
    ? ("booking:" + bookingId)
    : ("slot:" + slotWindow.slot_key + "|req:" + requesterEmail);

  if (bookingId) {
    var existing = findExistingEventByBookingId_(calendarId, bookingId);
    if (existing && existing.meet_link) {
      return {
        ok: true,
        status: "ok",
        meet_link: existing.meet_link,
        event_id: existing.event_id,
        created_at: existing.created_at || "",
        calendar_id: calendarId,
        guests: guests,
        message: "Existing Meet event reused (idempotent)."
      };
    }
    if (existing && existing.event_id && !existing.meet_link) {
      return failC_(
        "EXISTING_EVENT_WITHOUT_MEET_LINK",
        "An existing event was found but no Meet link is present.",
        "event_id=" + existing.event_id,
        existing.event_id,
        calendarId
      );
    }
  }

  var title = "Training Room Booking - " + (slotId || slotWindow.slot_key);
  var description =
    "Hybrid room booking\n" +
    "Booking ID: " + (bookingId || "(none)") + "\n" +
    "Requester: " + requesterName + " <" + requesterEmail + ">\n" +
    "Remote attendees: " + attendeeParse.valid.join(", ") + "\n" +
    "Generated by Script C.";

  var createRes = createEventWithMeet_(calendarId, {
    title: title,
    description: description,
    start_date: slotWindow.start_date,
    start_time: slotWindow.start_time,
    end_date: slotWindow.end_date,
    end_time: slotWindow.end_time,
    time_zone: timezone,
    guests: guests,
    booking_id: bookingId,
    slot_id: slotId || slotWindow.slot_key,
    id_key: idKey
  });

  if (!createRes || createRes.ok !== true) {
    return failC_(
      (createRes && createRes.error_code) || "MEET_CREATE_FAILED",
      (createRes && createRes.message) || "Meet creation failed.",
      createRes && createRes.error_details ? createRes.error_details : "",
      "",
      calendarId
    );
  }

  var meetLink = extractMeetLinkC_(createRes);
  var eventId = String(createRes.event_id || "").trim();
  if (!meetLink) {
    return failC_(
      "MEET_LINK_MISSING",
      "Calendar event created but no Meet link was returned.",
      createRes.message || "",
      eventId,
      calendarId
    );
  }

  return {
    ok: true,
    status: "ok",
    meet_link: meetLink,
    event_id: eventId,
    created_at: createRes.created_at || new Date().toISOString(),
    calendar_id: calendarId,
    guests: guests,
    message: createRes.message || "Meet link created."
  };
}

function createOnlineMeeting(params) {
  var res = createMeetForBooking_C_(params);
  return {
    ok: res.ok === true,
    created: res.ok === true && res.status === "ok",
    status: res.status || (res.ok ? "ok" : "failed"),
    meet_link: String(res.meet_link || "").trim(),
    event_id: String(res.event_id || "").trim(),
    created_at: String(res.created_at || "").trim(),
    calendar_id: String(res.calendar_id || resolveCalendarIdC_()).trim(),
    guests: Array.isArray(res.guests) ? res.guests : [],
    message: String(res.message || "").trim(),
    error_code: String(res.error_code || "").trim(),
    error_details: String(res.error_details || "").trim()
  };
}

/**
 * Parse slot ID: SLOT_2026-01-15_0800 -> {date:"2026-01-15", start_time:"08:00"}
 */
function parseSlotId_C(slotId) {
  if (!slotId) return null;
  var m = String(slotId).trim().toUpperCase().match(/^SLOT_(\d{4}-\d{2}-\d{2})_(\d{4})$/);
  if (!m) return null;
  var date = m[1];
  var hhmm = m[2];
  return { date: date, start_time: hhmm.slice(0, 2) + ":" + hhmm.slice(2, 4) };
}

/* =========================
 * Create event + meet link
 * ========================= */

function createEventWithMeet_(calendarId, payload) {
  try {
    if (typeof Calendar !== "undefined" && Calendar.Events && Calendar.Events.insert) {
      return createViaAdvancedCalendar_(calendarId, payload);
    }
  } catch (e1) {
    // Continue to fallback.
  }

  return createViaCalendarAppFallback_(calendarId, payload);
}

function createViaAdvancedCalendar_(calendarId, payload) {
  var requestId = stableRequestId_(payload.id_key);
  var attendees = (payload.guests || []).map(function (email) {
    return { email: email };
  });

  var eventResource = {
    summary: payload.title,
    description: payload.description,
    start: {
      dateTime: payload.start_date + "T" + payload.start_time + ":00",
      timeZone: payload.time_zone
    },
    end: {
      dateTime: payload.end_date + "T" + payload.end_time + ":00",
      timeZone: payload.time_zone
    },
    attendees: attendees,
    extendedProperties: {
      private: payload.booking_id
        ? { booking_id: payload.booking_id, slot_id: payload.slot_id || "" }
        : { id_key: payload.id_key }
    },
    conferenceData: {
      createRequest: {
        requestId: requestId,
        conferenceSolutionKey: { type: "hangoutsMeet" }
      }
    }
  };

  try {
    var created = Calendar.Events.insert(eventResource, calendarId, {
      conferenceDataVersion: 1,
      sendUpdates: "all"
    });

    return {
      ok: true,
      meet_link: extractMeetLinkFromEventC_(created),
      event_id: created && created.id ? String(created.id) : "",
      calendar_id: calendarId,
      guests: payload.guests || [],
      created_at: new Date().toISOString(),
      message: "Meet event created (Advanced Calendar API)."
    };
  } catch (err) {
    return failC_("ADVANCED_CALENDAR_CREATE_FAILED", "Calendar API event creation failed.", String(err), "", calendarId);
  }
}

function createViaCalendarAppFallback_(calendarId, payload) {
  try {
    var cal = CalendarApp.getCalendarById(calendarId) || CalendarApp.getDefaultCalendar();
    var startDate = new Date(payload.start_date + "T" + payload.start_time + ":00");
    var endDate = new Date(payload.end_date + "T" + payload.end_time + ":00");

    var event = cal.createEvent(payload.title, startDate, endDate, {
      description: payload.description,
      guests: (payload.guests || []).join(","),
      sendInvites: true
    });

    var meetLink = "";
    try {
      var conf = event.addConference("hangoutsMeet");
      var entryPoints = conf && conf.getEntryPoints ? conf.getEntryPoints() : [];
      if (entryPoints && entryPoints.length) {
        meetLink = String(entryPoints[0].getUri() || "").trim();
      }
    } catch (ignore) {
      // Event was created. Some tenants cannot attach Meet via CalendarApp.
    }

    return {
      ok: true,
      meet_link: meetLink,
      event_id: event.getId(),
      calendar_id: calendarId,
      guests: payload.guests || [],
      created_at: new Date().toISOString(),
      message: meetLink
        ? "Meet event created (CalendarApp fallback)."
        : "Event created but Meet link missing in fallback mode."
    };
  } catch (err) {
    return failC_("CALENDARAPP_CREATE_FAILED", "CalendarApp event creation failed.", String(err), "", calendarId);
  }
}

/* =========================
 * Idempotency: find existing
 * ========================= */

function findExistingEventByBookingId_(calendarId, bookingId) {
  var windowStart = new Date(new Date().getTime() - 14 * 24 * 60 * 60 * 1000);
  var windowEnd = new Date(new Date().getTime() + 90 * 24 * 60 * 60 * 1000);

  try {
    if (typeof Calendar !== "undefined" && Calendar.Events && Calendar.Events.list) {
      var resp = Calendar.Events.list(calendarId, {
        privateExtendedProperty: "booking_id=" + bookingId,
        timeMin: windowStart.toISOString(),
        timeMax: windowEnd.toISOString(),
        singleEvents: true,
        maxResults: 10,
        orderBy: "startTime"
      });

      var items = resp && resp.items ? resp.items : [];
      if (items.length) {
        var ev = items[0];
        return {
          event_id: String(ev.id || ""),
          meet_link: extractMeetLinkFromEventC_(ev),
          created_at: String(ev.created || "")
        };
      }
    }
  } catch (ignore) {
    // Fall through to CalendarApp fallback lookup.
  }

  try {
    var cal = CalendarApp.getCalendarById(calendarId) || CalendarApp.getDefaultCalendar();
    var searchTerm = "Booking ID: " + bookingId;
    var events = cal.getEvents(windowStart, windowEnd, { search: searchTerm }) || [];
    if (!events.length) return null;
    var event = events[0];
    var createdAt = "";
    try {
      if (event.getDateCreated) createdAt = event.getDateCreated().toISOString();
    } catch (ignoreCreated) {}
    return {
      event_id: event.getId ? String(event.getId() || "") : "",
      meet_link: extractMeetLinkFromCalendarAppEventC_(event),
      created_at: createdAt
    };
  } catch (ignore2) {
    return null;
  }
}

/* =========================
 * Helpers
 * ========================= */

function resolveCalendarIdC_(calendarIdParam) {
  var explicit = String(calendarIdParam || "").trim();
  if (explicit) return explicit;

  var props = PropertiesService.getScriptProperties();
  var fromProps = String(
    props.getProperty("MEET_CALENDAR_ID") ||
    props.getProperty("TRAINING_CALENDAR_ID") ||
    ""
  ).trim();
  return fromProps || "primary";
}

function getCalendarIdC_() {
  return resolveCalendarIdC_("");
}

function getTzC_() {
  var props = PropertiesService.getScriptProperties();
  var tz = String(props.getProperty("TRAINING_DEFAULT_TZ") || "").trim();
  return tz || Session.getScriptTimeZone() || "Africa/Johannesburg";
}

function buildGuestList_(requesterEmail, attendeeEmails) {
  var seen = {};
  var out = [];

  function add(email) {
    email = normalizeEmail_(email);
    if (!email || seen[email]) return;
    seen[email] = true;
    out.push(email);
  }

  add(requesterEmail);
  (attendeeEmails || []).forEach(add);

  if (out.length > 50) out = out.slice(0, 50);
  return out;
}

function normalizeEmail_(v) {
  var s = String(v || "").trim().toLowerCase();
  if (!s) return "";
  if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(s)) return "";
  return s;
}

function addMinutesToDateTime_(dateStr, timeStr, minutesToAdd) {
  var parts = String(dateStr || "").split("-");
  var t = String(timeStr || "").split(":");
  var y = parseInt(parts[0], 10);
  var m = parseInt(parts[1], 10) - 1;
  var d = parseInt(parts[2], 10);
  var hh = parseInt(t[0], 10);
  var mm = parseInt(t[1], 10);

  var dt = new Date(y, m, d, hh, mm, 0);
  dt = new Date(dt.getTime() + (minutesToAdd * 60 * 1000));

  var yyyy = dt.getFullYear();
  var MM = String(dt.getMonth() + 1).padStart(2, "0");
  var DD = String(dt.getDate()).padStart(2, "0");
  var HH = String(dt.getHours()).padStart(2, "0");
  var Min = String(dt.getMinutes()).padStart(2, "0");

  return { date: yyyy + "-" + MM + "-" + DD, time: HH + ":" + Min };
}

function stableRequestId_(idKey) {
  var base = String(idKey || "").trim();
  if (!base) base = Utilities.getUuid();
  base = base.replace(/[^a-zA-Z0-9_-]/g, "_");
  if (base.length > 59) base = base.slice(0, 59);
  return "meet_" + base;
}

function lowerTrim_(v) {
  return String(v || "").trim().toLowerCase();
}

function toPositiveInt_(v, fallback) {
  var n = parseInt(v, 10);
  if (isNaN(n) || n <= 0) return fallback;
  return n;
}

function normalizeMeetingTypeC_(rawType) {
  var s = lowerTrim_(rawType);
  if (
    s === "in_person_plus_online" ||
    s === "in_person_and_online" ||
    s === "in-person-plus-online" ||
    s === "inperson_plus_online" ||
    s === "hybrid" ||
    s === "online" ||
    s === "1" ||
    s === "true" ||
    s === "yes" ||
    s === "on"
  ) {
    return "in_person_plus_online";
  }
  return "in_person_only";
}

function resolveMeetingModeC_(rawType, hasRemoteAttendees) {
  var normalized = normalizeMeetingTypeC_(rawType);
  return {
    raw: lowerTrim_(rawType),
    requires_meet: normalized === "in_person_plus_online" || !!hasRemoteAttendees
  };
}

function parseAttendeeListC_(raw) {
  var tokens = [];

  function pushToken(v) {
    var s = String(v || "").trim();
    if (!s) return;
    tokens.push(s);
  }

  if (Array.isArray(raw)) {
    raw.forEach(pushToken);
    return tokens;
  }

  var s = String(raw || "").trim();
  if (!s) return [];

  if (s.startsWith("[") && s.endsWith("]")) {
    try {
      var parsed = JSON.parse(s);
      if (Array.isArray(parsed)) {
        parsed.forEach(pushToken);
        return tokens;
      }
    } catch (ignore) {
      // Fall through to delimited parsing.
    }
  }

  s.split(/[,;\n]+/).forEach(pushToken);
  return tokens;
}

function parseAttendeeEmailsC_(raw) {
  var src = parseAttendeeListC_(raw);
  var seen = {};
  var valid = [];
  var invalid = [];

  src.forEach(function (v) {
    var email = String(v || "").trim().toLowerCase();
    if (!email || seen[email]) return;
    seen[email] = true;
    if (normalizeEmail_(email)) valid.push(email);
    else invalid.push(email);
  });

  return { valid: valid, invalid: invalid };
}

function resolveSlotWindowC_(params, timezone) {
  var slotId = String(params.slot_id || "").trim();
  var slotMinutes = toPositiveInt_(params.slot_minutes, 60);
  if (slotMinutes <= 0) slotMinutes = 60;

  var startIsoRaw = String(params.start_iso || "").trim();
  var endIsoRaw = String(params.end_iso || "").trim();
  if (startIsoRaw && endIsoRaw) {
    var startDate = new Date(startIsoRaw);
    var endDate = new Date(endIsoRaw);
    if (isFinite(startDate.getTime()) && isFinite(endDate.getTime()) && endDate.getTime() > startDate.getTime()) {
      return {
        ok: true,
        start_date: formatDateByTzC_(startDate, timezone, "yyyy-MM-dd"),
        start_time: formatDateByTzC_(startDate, timezone, "HH:mm"),
        end_date: formatDateByTzC_(endDate, timezone, "yyyy-MM-dd"),
        end_time: formatDateByTzC_(endDate, timezone, "HH:mm"),
        slot_key: slotId || (startIsoRaw + "|" + endIsoRaw)
      };
    }
    return {
      ok: false,
      error_code: "INVALID_START_END_ISO",
      error_details: "start_iso/end_iso are invalid or end_iso <= start_iso"
    };
  }

  var parsed = parseSlotId_C(slotId);
  if (!parsed) {
    return {
      ok: false,
      error_code: "INVALID_SLOT_ID",
      error_details: "slot_id must match SLOT_YYYY-MM-DD_HHMM when start_iso/end_iso are not supplied."
    };
  }

  var end = addMinutesToDateTime_(parsed.date, parsed.start_time, slotMinutes);
  return {
    ok: true,
    start_date: parsed.date,
    start_time: parsed.start_time,
    end_date: end.date,
    end_time: end.time,
    slot_key: slotId
  };
}

function formatDateByTzC_(dateObj, timezone, pattern) {
  return Utilities.formatDate(dateObj, timezone || getTzC_(), pattern);
}

function extractMeetLinkFromEventC_(eventObj) {
  if (!eventObj) return "";
  var link = String(eventObj.hangoutLink || "").trim();
  if (link) return link;

  if (eventObj.conferenceData && eventObj.conferenceData.entryPoints) {
    for (var i = 0; i < eventObj.conferenceData.entryPoints.length; i++) {
      var ep = eventObj.conferenceData.entryPoints[i];
      if (ep && ep.entryPointType === "video" && ep.uri) {
        return String(ep.uri).trim();
      }
    }
  }

  return "";
}

function extractMeetLinkFromCalendarAppEventC_(eventObj) {
  if (!eventObj) return "";
  try {
    if (eventObj.getConferenceData) {
      var conferenceData = eventObj.getConferenceData();
      if (conferenceData && conferenceData.getEntryPoints) {
        var entryPoints = conferenceData.getEntryPoints() || [];
        for (var i = 0; i < entryPoints.length; i++) {
          var point = entryPoints[i];
          if (point && point.getEntryPointType && point.getEntryPointType() === "video" && point.getUri) {
            return String(point.getUri() || "").trim();
          }
        }
      }
    }
  } catch (ignore) {}
  return "";
}

function extractMeetLinkC_(resultObj) {
  if (!resultObj) return "";
  var direct = String(resultObj.meet_link || "").trim();
  if (direct) return direct;
  return extractMeetLinkFromEventC_(resultObj);
}

function failC_(code, message, details, eventId, calendarId) {
  return {
    ok: false,
    status: "failed",
    meet_link: "",
    event_id: String(eventId || "").trim(),
    created_at: "",
    calendar_id: String(calendarId || resolveCalendarIdC_("")).trim(),
    guests: [],
    message: message || "Error",
    error_code: code || "ERROR",
    error_details: details ? String(details) : ""
  };
}

/**
 * Non-destructive Script C property bootstrap.
 * Adds defaults only when keys are missing.
 *
 * Optional params:
 * - calendar_id
 * - timezone (or time_zone)
 */
function setupScriptCProperties_(params) {
  params = params || {};
  var props = PropertiesService.getScriptProperties();

  var meetCalendarId = String(props.getProperty("MEET_CALENDAR_ID") || "").trim();
  var trainingCalendarId = String(props.getProperty("TRAINING_CALENDAR_ID") || "").trim();
  var trainingTz = String(props.getProperty("TRAINING_DEFAULT_TZ") || "").trim();

  var desiredCalendarId = String(
    params.calendar_id ||
    meetCalendarId ||
    trainingCalendarId ||
    "primary"
  ).trim();

  var desiredTz = String(
    params.timezone ||
    params.time_zone ||
    trainingTz ||
    Session.getScriptTimeZone() ||
    "Africa/Johannesburg"
  ).trim();

  var updates = {};

  // Keep backward compatibility: if TRAINING_CALENDAR_ID already exists, do not override.
  if (!meetCalendarId && !trainingCalendarId) {
    updates.MEET_CALENDAR_ID = desiredCalendarId;
  }
  if (!trainingTz) {
    updates.TRAINING_DEFAULT_TZ = desiredTz;
  }

  var added = Object.keys(updates);
  if (added.length) {
    props.setProperties(updates, false);
  }

  return {
    ok: true,
    added_keys: added,
    calendar_id_effective: resolveCalendarIdC_(""),
    timezone_effective: getTzC_(),
    meet_calendar_id: String(props.getProperty("MEET_CALENDAR_ID") || "").trim(),
    training_calendar_id: String(props.getProperty("TRAINING_CALENDAR_ID") || "").trim(),
    training_default_tz: String(props.getProperty("TRAINING_DEFAULT_TZ") || "").trim()
  };
}

/**
 * Readiness status helper for Script C setup.
 * Safe to run repeatedly.
 */
function getScriptCSetupStatus_() {
  var props = PropertiesService.getScriptProperties();
  var meetCalendarId = String(props.getProperty("MEET_CALENDAR_ID") || "").trim();
  var trainingCalendarId = String(props.getProperty("TRAINING_CALENDAR_ID") || "").trim();
  var timezone = String(props.getProperty("TRAINING_DEFAULT_TZ") || "").trim();

  var effectiveCalendarId = resolveCalendarIdC_("");
  var calendarAccessible = false;
  var calendarAccessError = "";
  try {
    var cal = CalendarApp.getCalendarById(effectiveCalendarId) || CalendarApp.getDefaultCalendar();
    calendarAccessible = !!cal;
  } catch (err) {
    calendarAccessError = String(err || "");
  }

  var advancedServiceLinked = false;
  try {
    advancedServiceLinked = !!(typeof Calendar !== "undefined" && Calendar.Events);
  } catch (ignore) {}

  return {
    ok: true,
    properties: {
      MEET_CALENDAR_ID: meetCalendarId,
      TRAINING_CALENDAR_ID: trainingCalendarId,
      TRAINING_DEFAULT_TZ: timezone
    },
    effective: {
      calendar_id: effectiveCalendarId,
      timezone: getTzC_()
    },
    checks: {
      calendar_accessible: calendarAccessible,
      calendar_access_error: calendarAccessError,
      advanced_calendar_service_linked: advancedServiceLinked
    },
    recommended_next: [
      "1) Run setupScriptCProperties_() once.",
      "2) Add Calendar advanced service (identifier: Calendar).",
      "3) Run authorizeScriptC_() and accept permissions."
    ]
  };
}

/**
 * One-time manual authorization helper for Script C.
 *
 * Run this in the Apps Script editor as the script owner.
 * It validates Calendar write access by creating + deleting a short-lived event.
 * It also probes the Advanced Calendar service if enabled.
 */
function authorizeScriptC_() {
  var resolvedCalendarId = resolveCalendarIdC_("");
  var cal = CalendarApp.getCalendarById(resolvedCalendarId) || CalendarApp.getDefaultCalendar();
  if (!cal) {
    throw new Error(
      "Calendar not accessible. Set Script Property MEET_CALENDAR_ID (or TRAINING_CALENDAR_ID) to a valid calendar ID."
    );
  }

  var start = new Date(Date.now() + 5 * 60 * 1000);
  var end = new Date(start.getTime() + 30 * 60 * 1000);
  var title = "[Script C Auth Test] " + new Date().toISOString();

  var tempEvent = cal.createEvent(title, start, end, {
    description: "Temporary event created by authorizeScriptC_() for permission validation."
  });

  var deleted = false;
  try {
    tempEvent.deleteEvent();
    deleted = true;
  } catch (ignoreDelete) {}

  var advancedCalendarReady = false;
  var advancedCalendarError = "";
  try {
    if (typeof Calendar !== "undefined" && Calendar.Events && Calendar.Events.list) {
      Calendar.Events.list(cal.getId(), {
        maxResults: 1,
        timeMin: new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString(),
        singleEvents: true
      });
      advancedCalendarReady = true;
    }
  } catch (err) {
    advancedCalendarError = String(err || "");
  }

  return {
    ok: true,
    calendar_id: cal.getId(),
    temp_event_id: tempEvent.getId(),
    temp_event_deleted: deleted,
    advanced_calendar_ready: advancedCalendarReady,
    advanced_calendar_error: advancedCalendarError
  };
}
